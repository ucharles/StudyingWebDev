# Mongo DB

## Pattern

패턴은 데이터 모델을 최대한 활용하는 방법.
주요 목표: 주어진 사용 사례, 혹은 액세스 패턴에 맞춰 스키마를 최적화 하는 것

각 패턴은 아래를 야기할 수 있습니다:

1. 문서 간의 데이터 중복
2. 일부 데이터의 부실
3. 참조 무결성을 보장하는 애플리케이션 측 추가 로직 작성

### Duplication

데이터를 복제하고 지속적으로 업데이트 해야하는 경우, 대량 업데이트로 중복을 해결할 것.

중복이 중복하지 않는 경우보다 나은 경우:

- 주문 내의 주소 정보. 주문 시의 주소는 바뀌지 않아야 한다.
- 복사 데이터가 변경되지 않는 경우. 영화 개봉 후엔 배우의 목록이 변경되지 않는다.

중복하지 않는 것이 나은 경우:

- 계산이 필요한 데이터? 영화 하나가 있고, 각 스크린 별 매출을 기록한 데이터가 있을 때, 매출의 총 합계를 영화 컬렉션에 반영하는 것은 좋지 않은 선택. 데이터가 중복되며, 이를 적용할 경우 참조 무결성을 유지해야 할 필요가 있음.

### Staleness(Not new data)

- 얼마동안, 사용자가 최신 값을 보지 못하는 것을 용인할 수 있는지?
  분석 쿼리는 세컨더리 노드에서 실행됨. 오래된 데이터가 있을 수 있다.
- 모든 데이터에는 임계값(threshold)이 존재한다.

해결하는 방법

- 배치 업데이트.
- 스트림 변경을 사용하여 변경을 찾는다.

[Change Streams] (https://docs.mongodb.com/manual/changeStreams/)
데이터의 변화를 관찰할 수 있음.
a single collection, a database, or an entire deployment(전체 배포)

### 참조 무결성 (Referential Integrity)

왜 발생하는가?
어떤 데이터를 삭제한 결과일 수 있다.
MongoDB는 cascading update, delete를 지원하지 않기 때문.
애플리케이션 자체에서 참조 무결성을 유지할 책임이 있다.

- 지연된 참조 무결성의 경우, Change Streams에 의존할 수 있음.
- 단일 문서 유지(참조 자체를 사용하지 않는다)
- 다중 문서 트랜잭션 사용

### Attribute Pattern (속성 패턴)

해결하고자 하는 것

- 수많은 유사한 필드
- 한번에 많은 필드를 검색하고 싶음
- 필드는 문서의 오직 작은 subset을 나타낸다.

1. 근본이 되는 Schema를 정의하고, 추가되는 속성들은 "add specs" 속성의 배열로 관리한다. 그 배열의 형태는 {"k":"", "v":""}
2. 값의 내용이 비슷한 속성들은 또다시 배열로 묶을 수 있다. 예를 들어, 개봉일의 경우, 각 나라마다 개봉일이 다를 것인데, 전부 따로 key:value를 할당할 것이 아니라, releases 속성의 배열로 관리할 수 있다.
   ![attributePattern](./1_Pattern/image/2022-02-04 23.25.35.png)

사용 예

- 제품의 특성
- 같은 값을 가지고 있는 필드를 설정할 때

장점

- 쉬운 인덱싱.
- key 이름을 미리 알 필요가 없다.
- 기존 key:value에 더해 추가 구성을 할 수 있다.

### Reference Pattern (확장 참조 패턴)

Mongo DB에선 $lookup, $graphLookup을 사용하여 조인할 수 있다.
하지만 물리적 조인을 피하기 위해, 컬렉션 안에 array를 포함시킬 수 있다.
주로 변경이 많지 않은 데이터일 경우 적용하는 패턴이다.
(주문서의 배송지, 청구지)

확장 참조 패턴이 해결하고자 하는 것

- 쿼리에서 수많은 데이터 조각을 조인하는 것을 피하기 위해. 확장 참조 패턴으로 데이터를 사전 결합할 수 있다.

해결법

- lookup 사이드에 있는 데이터를 식별
- 메인 오브젝트에 위의 데이터를 포함하기

사용예

- 카탈로그
- 모바일 애플리케이션
- 실시간 분석

장점과 단점

- 빠른 읽기 속도
- 조인 횟수와 lookup 횟수를 줄일 수 있다
- 확장 참조에 변경이 많은(mutate a lot) 필드를 포함할 경우, 많은 중복을 야기할 수 있다.

### Subset Pattern

MongoDB는 Disk에서 필요한 문서만 RAM에 가져온다.
RAM에 더이상 공간이 없을 때, 필요하지 않은 문서를 RAM에서 제거한다.
RAM에 존재하는 Document를 Working Set이라고 칭한다.
Working Set의 크기가 RAM 크기보다 작은 한, 좋은 성능을 얻을 수 있다.
Working Set은 자주 접근하는 Document 및 Index가 차지하는 공간입니다.

Working Set이 RAM보다 큰 경우...

1. RAM 추가하기.(수직 크기 조정)
2. Sharding을 도입하거나, Shard를 늘리거나.(수평 크기 조정)
3. Working Set의 크기를 줄이기.

Working Set의 크기를 줄이는 방법.

- 한 컬렉션을 두 개의 컬렉션으로 분할한다. (자주 접근하는 것과 자주 접근하지 않는 것)
- 주로 1-N, N-N 관계에서 더 자주 사용되는 쪽에 적용한다.

사용예

- 제품의 리뷰 목록
- 댓글 목록
- 영화의 출연진 목록

장점과 단점

- Working Set을 줄이고, 자주 사용되는 Document의 크기도 줄일 수 있다.
- 추가 문서를 더 빠르게 검색할 수 있음.
- 검색할 문서가 많음. 애플리케이션과 서버간의 통신이 많이 발생.
- 문서를 분할함으로써 정보를 복제하기 때문에, 디스크에 좀 더 많은 공간이 필요하다.(치명적이지 않음, RAM보다 훨씬 저렴함)
